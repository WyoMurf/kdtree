
K-d Tree Geometrical Data Structure Package

David Harrison
University of California, Berkeley
----------------------------------

A number of additions, enhancements by:
Steve Murphy
----------------------------------

This is an implementation of k-d trees as described by Rosenberg
in "Geographical Data Structures", IEEE Transactions on CAD, Vol. CAD-4, 
No. 1, January 1988.  His work is based on that of Jon Bentley in
"Multidimensional Binary Search Trees used for Associative Searching",
CACM, Vol. 18, No. 9, pp. 509-517, Sept. 1975.

K-d trees are used to store records with multiple keys.  The tree
itself is binary: each node has no more than two children.  However,
the value used to divide the space into two spaces varies with
the level of the tree.  For example,  the comparison value at the 
top node is the first key,  the value at the next level is the 
second key,  etc.  This cycle repeats once all keys have been
exhausted.

The implementation of k-d trees given here is designed for storing
two-dimensional geometric objects.  All objects are assumed to have a
size that can be represented as a rectangle (in most cases,  this is
the bounding box of the object).  The implementation uses this fact to
represent a collection of objects as a 4-d tree (each edge of the
rectangle is treated as a key).  The package supports the following
operations:

	kd_build:	Efficiently build a new tree from a list of
			objects.  O(n log n) time,  O(n) memory.
	kd_insert:	Insert a new item into the tree. O(log n)
			time,  O(log n) memory.
	kd_delete:	Delete an item from a tree.  O(log n) time,
			O(log n) memory.
    kd_really_delete: Deletes an item from the tree for real,
            instead of marking it dead. Odds are that the node
            is near the bottom of the tree, and the operation
            will not be super expensive. O(log n) minimum.
	kd_start, kd_next, kd_end:
			Find all objects in a region.  Time is
			proportional to the ratio of the region to the
			overall region of objects.  In general,  k-d
			trees tend to perform better (on average) than
			quad trees or binary trees.
    kd_nearest
            Find the N nearest objects to a point in space.
            They are returned via an array of {dist*dist, elem}
            the 0th elem the closest. The centroids are used to
            determine distances. Distance squared is used, and
            because it is, the distances are kept track of in f.p.
            notation. O(k * log n). In other words, search time
            proportional to log n.
	kd_rebuild
            Rebuilds a tree by ripping it into a linked list and
            building a new tree from that. O(n * (1 + log n))

The actual data stored in the tree are generic pointers (kd_generic).
These pointers could point to user allocated structures or the could
be user defined object identifiers for retrieving the objects from other
data structures.  Note: this package requires these generic pointers
to be unique and non-zero.


Status Codes
------------

Many of the routines described on the following pages return kd_status
(an integer return code).  The possible return codes are described
below:

Positive (non-fatal):

KD_OK		Routine completed successfully.
KD_NOMORE	No more objects in the specified region.

Negative (fatal):

KD_NOTFOUND	Item is not in tree.

A textual description of an error can be obtained using the following
function:

char *kd_err_string()

	Returns a textual description of the last error encountered.
	The string is owned by this package and should not be
	modified.

Fatal errors are signalled by calling a fault handler provided by
the error handling package `errtrap'.  By default,  the fault handler
prints out a descriptive message and calls abort().  However,  it is
possible to override this behaviour.  See `errtrap.doc' for details.
Below is a list of the serious errors generated by kd:

KDF_M ("out of memory")
	All available memory has been exhausted.

KDF_ZEROID ("attempt to insert null data")
	A zero pointer was passed to kd_insert (possibly through
	kd_build).

KDF_MD ("bad median")
	A bad median was chosen during tree build.

KDF_F ("bad father node")
	Corrupt tree detected during delete.

KDF_DUPL ("attempt to insert duplicate item")
	Data stored in the tree must have distinct generic pointers.

KDF_UNKNOWN ("unknown fault: %d")
	Some unknown error has occurred.


Creating, Building, and Deleting Trees
--------------------------------------

kd_tree kd_create()

	Creates a new k-d tree and returns its handle.  This handle is
	used by all other k-d tree operations.  It can be freed using
	kd_destroy().  

kd_tree kd_build(itemfunc, arg)
   int (*itemfunc)();		/* Returns new items       */
   kd_generic arg;			/* Data to itemfunc        */

	This routine builds a new, reasonably balanced k-d tree
	from a list of items.  This list of items is collected
	by repeatedly calling `itemfunc' using the following
	arguments:
	  int itemfunc(arg, val, size)
	  kd_generic arg;
	  kd_generic *val;
	  kd_box size;
	Each time the itemfunc is called,  it should return the
	next item to be placed in the tree in `val',  the bounding
	box of the item in `size',  and return a non-zero value.  
	When there are no more items,  the routine should return zero.
	`itemfunc' is guaranteed to be called for all items. `arg' is 
	passed as a convenience (usually for state information).

void kd_destroy(tree, delfunc)
   kd_tree tree;			/* k-d tree to destroy 		     */
   void (*delfunc)();		/* Free function called on user data */

	This routine frees all resources associated with `tree'.  If
	the tree is non-empty and `delfunc' is non-zero,  `delfunc'
	will be called for each item in the tree.  Its form is as follows:
	   void delfunc(data)
	   kd_generic data;
	This function can be used to free memory allocated by the
	caller.

Inserting and Deleting Objects
------------------------------

void kd_insert(theTree, data, size)
   kd_tree theTree;		/* k-d tree for insertion */
   kd_generic data;		/* User supplied data     */
   kd_box size;			/* Size of item           */

	Inserts a new data item into the specified k-d tree. 
	The routine produces only fatal diagnostics (see "Status
	Codes" above).  The routine does not allow items with the same
	data fields to be stored in the same tree.  Note it IS legal
	to store items with the same size.

kd_status kd_delete(theTree, data, old_size)
   kd_tree theTree;		/* Tree to delete from  */
   kd_generic data;		/* Item to delete       */
   kd_box old_size;		/* Original size        */

	Deletes the specified item from the specified k-d tree.  
	May return KD_NOTFOUND if the item is not in the tree.
    This routine leaves the node in theTree, marked DEAD
    by nullifying its kd_generic object entry.

kd_status kd_really_delete(theTree, data, old_size, num_tries, num_del)
   kd_tree theTree;		/* Tree to delete from  */
   kd_generic data;		/* Item to delete       */
   kd_box old_size;		/* Original size        */
   int *num_tries, *num_del; /* stats returned about how much work it took */

    Deletes the item from the tree by replacing it with
    the appropriate node from one of its subtrees. This
    node is likewise deleted, and so on recursively. Average
    delete times are actually very quick. Consider that
    50% of the nodes are at the leaves. 75% are at the
    leaves or one level above. 87.5% are 2 levels or less
    from the leaves. 93.75% are 3 levels or less from the
    leaves, and so on. So The vast majority of nodes will
    delete very quickly. The node IS DESTROYED from the tree.
    Dead nodes below the deleted one ARE NOT DELETED. This
    means that one delete method or the other should be implemented.
    A node from the HISON or LOSON could be chosen for replacing
    the deleted node. When both are available, one side is randomly
    chosen.  num_tries   and  num_del are    statistics
    returned about the search itself.


Region Searching
----------------

This package implements region search using the generator paradigm.
Generating items in a region is a three step process:
   1.  Call kd_start() to specify the region.  This routine returns a
       `generator' that is passed to kd_next() and kd_finish().
   2.  Repeatedly call kd_next() to get the next item in the region.
       This function is usually called until it returns KD_NOMORE.
   3.  Call kd_finish() to reclaim the resources consumed by the
       generator.

kd_gen kd_start(theTree, area)
   kd_tree theTree;		/* Tree to generate from */
   kd_box area;			/* Area to search 	 */

	This routine allocates a generator which can be used
	to generate all items intersecting `area'.
	The items are actually returned by kd_next.  Once the
	sequence is finished,  kd_finish should be called.

kd_status kd_next(theGen, data, size)
   kd_gen theGen;			/* Current generator */
   kd_generic *data;		/* Returned data     */
   kd_box size;			/* Optional size     */

	Returns the next data item in the generator sequence.  If
	`size' is non-zero,  it will be filled with the item's
	current bounding box. If there are no more data items in 
	the region,  the routine returns KD_NOMORE.

int kd_finish(theGen)
   kd_gen theGen;			/* Generator to destroy */

	Frees resources consumed by the specified generator.
	This routine is NOT automatically called at the end
	of a sequence.  Thus,  the user should ALWAYS calls
	kd_finish to end a generation sequence. Returns the
    number of elements visited in the traversal.


Nearest Neighbor Searching
--------------------------

This is done by reporting the number of items wished, and then
getting back a prioritized list. 

int kd_nearest(tree, x, y, m, alist)
   kd_tree tree;
   int x,  y,  m;
   kd_priority **alist;

   This routine will calloc an alist for  you. Remember
   to  free it when  you are  done with   it. m is  the
   number of elements to find.  x and y is the point to
   find the  things   nearest  to.   It  will calculate
   distances   as the  distance    squared, in database
   units,  and as  doubles (to   avoid overflow).   The
   distance of  a box to   the point is  done by  first
   calculating the centroid of the box, then using this
   centroid  in  a   point-point  distance calc. Search
   times depend on the number  of  nodes wished, and is
   dependent on  log n.   kd_nearest returns the number
   of nodes visited during the search.

int kd_print_nearest(tree, x, y, m)
   kd_tree tree;
   int x,  y,  m;

   kd_print_nearest prints out the results of the search.


General Purpose
---------------

int kd_count(tree)
    kd_tree tree;

Returns  the  number of items  stored in the  specified
   tree. This is a constant time operation.

kd_status kd_is_member(theTree, data, size)
    kd_tree theTree;		/* Tree to examine  */
    kd_generic data;		/* Item to look for */
    kd_box size;			/* Original size    */

   This routines return  KD_OK is 'data'  with  bb size
   is  stored  in the   tree. If not,   KD_NOTFOUND  is
   returned. Sets the path traversed in preparation for
   the kd_print_path function.

void kd_badness(tree)
    kd_tree tree;

    Prints on  stdout, a  set of metrics  on the health
   of  a  kd  tree. balance ratio    is the maxdepth  /
   mindepth  figure.  The  closer   to 1, the   better.
   #of nodes  with  one son  is a  count of just  that.
   The  more,  the worse. Dead   nodes  are a  count of
   nodes    deleted    with   kd_delete,   and    still
   remaining in the tree. 


void kd_print(tree)
    kd_tree tree;

   This    prints   out  a    tree   by   following   a
   recursive   algorithm: Print    Self,   visit   left
   son,    then  visit  right    son.    Asterisks  are
   printed in front  of  discriminators.  One line  per
   node. For trees  with  large numbers  of nodes, this
   will yield large amounts of data. Caution. 


void kd_print_path() /* this routine is for debug */

   This  routine  will print to   stdout, the  path the
   last search  took thru the  kd tree. It's mostly for
   debug, but is provided for the kd enthusiast.

kd_tree kd_rebuild(tree)
    kd_tree tree;

   This  routines  take the  tree apart  and builds  it
   again. This is an expensive operation. O(N + Nlog N)
   time. Should only be  used when  the  badness  stats
   indicate  serious    degradation.    Considering the
   resilience of kd trees  to degradation, this routine
   may never  be needed. The  only thing that could  be
   said in its favor is  that it doesn't call malloc at
   all, so  it's   much faster than  the  initial build
   call. 
